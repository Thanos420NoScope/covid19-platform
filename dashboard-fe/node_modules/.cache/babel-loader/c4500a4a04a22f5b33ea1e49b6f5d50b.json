{"ast":null,"code":"/** pact-lang-api.js\n * Exports functions to support Pact API calls.\n * Author: Will Martino, Hee Kyun Yun, Stuart Popejoy\n * Supports: Pact API 3.0 v1\n */\nconst blake = require(\"blakejs\");\n\nconst nacl = require(\"tweetnacl\");\n\nconst base64url = require(\"base64-url\");\n\nconst fetch = require(\"node-fetch\");\n/**\n * Convert binary to hex.\n * @param s {Uint8Array} - binary value\n * @return {string} hex string\n */\n\n\nvar binToHex = function (s) {\n  var constructor = s.constructor.name || null;\n\n  if (constructor !== \"Uint8Array\") {\n    throw new TypeError(\"Expected Uint8Array\");\n  }\n\n  return Buffer.from(s).toString(\"hex\");\n};\n/**\n * Convert hex string to binary.\n * @param s {string} - hex string\n * @return {Uint8Array} binary value\n */\n\n\nvar hexToBin = function (h) {\n  if (typeof h !== \"string\") {\n    throw new TypeError(\"Expected string: \" + h);\n  }\n\n  return new Uint8Array(Buffer.from(h, \"hex\"));\n};\n/**\n * Perform blake2b256 hashing.\n */\n\n\nvar hashBin = function (s) {\n  return blake.blake2b(s, null, 32);\n};\n/**\n * Perform blake2b256 hashing, encoded as unescaped base64url.\n */\n\n\nvar hash = function (s) {\n  return base64UrlEncode(hashBin(s));\n};\n/**\n * Hash string as unescaped base64url.\n */\n\n\nvar base64UrlEncode = function (s) {\n  return base64url.escape(base64url.encode(s));\n};\n/**\n * Generate a random ED25519 keypair.\n * @return {object} with \"publicKey\" and \"secretKey\" fields.\n */\n\n\nvar genKeyPair = function () {\n  var kp = nacl.sign.keyPair();\n  var pubKey = binToHex(kp.publicKey);\n  var secKey = binToHex(kp.secretKey).slice(0, 64);\n  return {\n    publicKey: pubKey,\n    secretKey: secKey\n  };\n};\n\nvar toTweetNaclSecretKey = function (keyPair) {\n  if (!keyPair.hasOwnProperty(\"publicKey\") || !keyPair.hasOwnProperty(\"secretKey\")) {\n    throw new TypeError(\"Invalid KeyPair: expected to find keys of name 'secretKey' and 'publicKey': \" + JSON.stringify(keyPair));\n  }\n\n  return hexToBin(keyPair.secretKey + keyPair.publicKey);\n};\n/**\n * Sign data using key pair.\n * @param msg - some data to be passed to blake2b256.\n * @param keyPair - signing ED25519 keypair\n * @return {object} with \"hash\", \"sig\" (signature in hex format), and \"pubKey\" public key value.\n */\n\n\nvar sign = function (msg, keyPair) {\n  var hshBin = hashBin(msg);\n  var hsh = base64UrlEncode(hshBin);\n\n  if (!keyPair.hasOwnProperty(\"publicKey\") && !keyPair.hasOwnProperty(\"secretKey\")) {\n    return {\n      hash: hsh,\n      sig: undefined\n    };\n  } else if (keyPair.hasOwnProperty(\"publicKey\") && (!keyPair.hasOwnProperty(\"secretKey\") || !keyPair.secretKey)) {\n    return {\n      hash: hsh,\n      sig: \"REPLACE THIS WITH SIGNATURE\"\n    };\n  }\n\n  var sigBin = nacl.sign.detached(hshBin, toTweetNaclSecretKey(keyPair));\n  return {\n    hash: hsh,\n    sig: binToHex(sigBin)\n  };\n};\n\nvar pullAndCheckHashs = function (sigs) {\n  var hsh = sigs[0].hash;\n\n  for (var i = 1; i < sigs.length; i++) {\n    if (sigs[i].hash !== hsh) {\n      throw new Error(\"Sigs for different hashes found: \" + JSON.stringify(sigs));\n    }\n  }\n\n  return hsh;\n};\n/**\n * Prepare an ExecMsg pact command for use in send or local execution.\n * To use in send, wrap result with 'mkSingleCommand'.\n * @param keyPairs {array or object} - array or single ED25519 keypair and/or clist (list of `cap` in mkCap)\n * @param nonce {string} - nonce value for ensuring unique hash - default to current time\n * @param pactCode {string} - pact code to execute - required\n * @param envData {object} - JSON of data in command - not required\n * @param meta {object} - public meta information, see mkMeta\n * @return valid pact API command for send or local use.\n */\n\n\nvar prepareExecCmd = function (keyPairs = [], nonce = new Date().toISOString(), pactCode, envData, meta = mkMeta(\"\", \"\", 0, 0, 0, 0), networkId = null) {\n  enforceType(nonce, \"string\", \"nonce\");\n  enforceType(pactCode, \"string\", \"pactCode\");\n  var kpArray = asArray(keyPairs);\n  kpArray = kpArray.filter(kp => !!kp.publicKey);\n  var signers = kpArray.map(mkSigner);\n  var cmdJSON = {\n    networkId: networkId,\n    payload: {\n      exec: {\n        data: envData || {},\n        code: pactCode\n      }\n    },\n    signers: signers,\n    meta: meta,\n    nonce: JSON.stringify(nonce)\n  };\n  var cmd = JSON.stringify(cmdJSON);\n  var sigs = kpArray.length === 0 ? [sign(cmd, kpArray)] : kpArray.map(kp => sign(cmd, kp));\n  return mkSingleCmd(sigs, cmd);\n};\n/**\n * Prepare an ContMsg pact command for use in send or local execution.\n * To use in send, wrap result with 'mkSingleCommand'.\n * @param keyPairs {array or object} - array or single ED25519 keypair and/or clist (list of `cap` in mkCap)\n * @param nonce {string} - nonce value for ensuring unique hash - default to current time\n * @param step {number} - integer index of step to execute in defpact body - required\n * @param proof {string} - JSON of SPV proof, required for cross-chain transfer. See `fetchSPV` below\n * @param rollback {bool} - Indicates if this continuation is a rollback/cancel- required\n * @param pactId {string} - identifies the already-begun Pact execution that this is continuing - required\n * @param envData {object} - JSON of data in command - not required\n * @param meta {object} - public meta information, see mkMeta\n * @return valid pact API Cont command for send or local use.\n */\n\n\nvar prepareContCmd = function (keyPairs = [], nonce = new Date().toISOString(), proof, pactId, rollback, step, envData, meta = mkMeta(\"\", \"\", 0, 0, 0, 0), networkId = null) {\n  enforceType(nonce, \"string\", \"nonce\");\n  var kpArray = asArray(keyPairs);\n  var kpArray = asArray(keyPairs);\n  kpArray = kpArray.filter(kp => !!kp.publicKey);\n  var signers = kpArray.map(mkSigner);\n  var cmdJSON = {\n    networkId: networkId,\n    payload: {\n      cont: {\n        proof: proof || null,\n        pactId: pactId,\n        rollback: rollback,\n        step: step,\n        data: envData || {}\n      }\n    },\n    signers: signers,\n    meta: meta,\n    nonce: JSON.stringify(nonce)\n  };\n  var cmd = JSON.stringify(cmdJSON);\n  var sigs = kpArray.map(function (kp) {\n    return sign(cmd, kp);\n  });\n  return mkSingleCmd(sigs, cmd);\n};\n/**\n * Makes a single command given signed data.\n * @param sigs {array} - array of signature objects, see 'sign'\n * @param cmd {string} - stringified JSON blob used to create hash\n * @return valid Pact API command for send or local use.\n */\n\n\nvar mkSingleCmd = function (sigs, cmd) {\n  enforceArray(sigs, \"sigs\");\n  enforceType(cmd, \"string\", \"cmd\");\n  return {\n    hash: pullAndCheckHashs(sigs),\n    sigs: sigs.filter(s => {\n      if (s.sig === undefined) return false;else return true;\n    }).map(s => {\n      return {\n        sig: s.sig\n      };\n    }),\n    cmd: cmd\n  };\n};\n/**\n * Makes outer wrapper for a 'send' endpoint.\n * @param {array or object} cmds - one or an array of commands, see mkSingleCmd\n */\n\n\nvar mkPublicSend = function (cmds) {\n  return {\n    cmds: asArray(cmds)\n  };\n};\n/**\n * Make an ED25519 \"signer\" array element for inclusion in a Pact payload.\n * @param {object} kp - a ED25519 keypair and/or clist (list of `cap` in mkCap)\n * @return {object} an object with pubKey, addr and scheme fields.\n */\n\n\nvar mkSigner = function (kp) {\n  return {\n    clist: kp.clist ? asArray(kp.clist) : [],\n    pubKey: kp.publicKey\n  };\n};\n\nvar asArray = function (singleOrArray) {\n  if (Array.isArray(singleOrArray)) {\n    return singleOrArray;\n  } else {\n    return [singleOrArray];\n  }\n};\n\nvar enforceType = function (val, type, msg) {\n  if (typeof val !== type) {\n    throw new TypeError(msg + \" must be a \" + type + \": \" + JSON.stringify(val));\n  }\n};\n\nvar enforceArray = function (val, msg) {\n  if (!Array.isArray(val)) {\n    throw new TypeError(msg + \" must be an array: \" + JSON.stringify(val));\n  }\n};\n/**\n * Make a full 'send' endpoint exec command. See 'prepareExecCmd' for parameters.\n */\n\n\nvar simpleExecCommand = function (keyPairs, nonce, pactCode, envData, meta, networkId) {\n  return mkPublicSend(prepareExecCmd(keyPairs, nonce, pactCode, envData, meta, networkId));\n};\n/**\n * Make a full 'send' endpoint cont command. See 'prepareContCmd' for parameters.\n */\n\n\nvar simpleContCommand = function (keyPairs, nonce, step, pactId, rollback, envData, meta, proof, networkId) {\n  return mkPublicSend(prepareContCmd(keyPairs, nonce, proof, pactId, rollback, step, envData, meta, networkId));\n};\n\nvar unique = function (arr) {\n  var n = {},\n      r = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (!n[arr[i]]) {\n      n[arr[i]] = true;\n      r.push(arr[i]);\n    }\n  }\n\n  return r;\n};\n/**\n * Given an exec 'send' message, prepare a message for 'poll' endpoint.\n * @param execMsg {object} JSON with \"cmds\" field, see 'mkPublicSend'\n * @return {object} with \"requestKeys\" for polling.\n */\n\n\nvar simplePollRequestFromExec = function (execMsg) {\n  var cmds = execMsg.cmds || TypeError(\"expected key 'cmds' in object: \" + JSON.stringify(execMsg));\n  var rks = [];\n\n  if (!cmds.every(function (v) {\n    return v.hasOwnProperty(\"hash\");\n  })) {\n    throw new TypeError('maleformed object, expected \"hash\" key in every cmd: ' + JSON.stringify(execMsg));\n  } else {\n    rks = unique(cmds.map(function (v) {\n      return v.hash;\n    }));\n  }\n\n  return {\n    requestKeys: rks\n  };\n};\n/**\n * Given an exec 'send' message, prepare a message for 'listen' endpoint.\n * @param execMsg {object} JSON with \"cmds\" field, see 'mkPublicSend'. Only takes first element.\n * @return {object} with \"requestKey\" for polling.\n */\n\n\nvar simpleListenRequestFromExec = function (execMsg) {\n  var cmds = execMsg.cmds || TypeError(\"expected key 'cmds' in object: \" + JSON.stringify(execMsg));\n  var rks = [];\n\n  if (!cmds.every(function (v) {\n    return v.hasOwnProperty(\"hash\");\n  })) {\n    throw new TypeError('maleformed object, expected \"hash\" key in every cmd: ' + JSON.stringify(execMsg));\n  } else {\n    rks = unique(cmds.map(function (v) {\n      return v.hash;\n    }));\n  }\n\n  return {\n    listen: rks[0]\n  };\n};\n/**\n * Variadic function to form a lisp s-expression application.\n * Encases arguments in parens and intercalates with a space.\n */\n\n\nvar mkExp = function (pgmName) {\n  enforceType(pgmName, \"string\", \"pgmName\");\n  return \"(\" + pgmName + \" \" + Array.prototype.slice.call(arguments, 1).map(JSON.stringify).join(\" \") + \")\";\n};\n/**\n * Prepare a chainweb-style public meta payload.\n * @param sender {string} gas account\n * @param chainId {string} chain identifier\n * @param gasPrice {number} desired gas price\n * @param gasLimit {number} desired gas limit\n * @param creationTime {number} desired tx's time created in UNIX epoch time as seconds\n * @param ttl {number} desired tx's time to live as seconds\n * @return {object} of arguments, type-checked and properly named.\n */\n\n\nvar mkMeta = function (sender, chainId, gasPrice, gasLimit, creationTime, ttl) {\n  enforceType(sender, \"string\", \"sender\");\n  enforceType(chainId, \"string\", \"chainId\");\n  enforceType(gasPrice, \"number\", \"gasPrice\");\n  enforceType(gasLimit, \"number\", \"gasLimit\");\n  enforceType(creationTime, \"number\", \"creationTime\");\n  enforceType(ttl, \"number\", \"ttl\");\n  return {\n    creationTime: creationTime,\n    ttl: ttl,\n    gasLimit: gasLimit,\n    chainId: chainId,\n    gasPrice: gasPrice,\n    sender: sender\n  };\n};\n/**\n * Formats ExecCmd into api request object\n */\n\n\nvar mkReq = function (cmd) {\n  return {\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    method: \"POST\",\n    body: JSON.stringify(cmd)\n  };\n};\n/**\n * An execCmd Object to Execute in send or local.\n * @typedef {Object} cmd to `/send` endpoint\n * @property type {string} - type of command - \"cont\" or \"exec\", default to \"exec\"\n * @property pactCode {string} - pact code to execute in \"exec\" command - required for \"exec\"\n * @property nonce {string} - nonce value to ensure unique hash - default to current time\n * @property envData {object} - JSON of data in command - not required\n * @property meta {object} - public meta information, see mkMeta\n * @property networkId {object} network identifier of where the cmd is executed.\n */\n\n/**\n * A contCmd to Execute in send\n * @typedef {Object} cmd to `/send` endpoint\n * @property type {string} - type of command - \"cont\" or \"exec\", default to \"exec\"\n * @property pactId {string} - pactId the cont command - required for \"cont\"\n * @property nonce {string} - nonce value to ensure unique hash - default to current time\n * @property step {number} - the step of the mutli-step transaction - required for \"cont\"\n * @property proof {string} - JSON of SPV proof, required for cross-chain transfer. See `fetchSPV` below\n * @property rollback {bool} - Indicates if this continuation is a rollback/cancel - required for \"cont\"\n * @property envData {object} - JSON of data in command - not required\n * @property meta {object} - public meta information, see mkMeta\n * @property networkId {object} network identifier of where the cmd is executed.\n */\n\n/**\n * Sends Pact command to a running Pact server and retrieves tx result.\n * @param {[execCmd or contCmd] or execCmd or contCmd} cmd or a list of cmds to execute\n * @param {string} apiHost host running Pact server\n * @return {object} Request key of the tx received from pact server.\n */\n\n\nconst fetchSend = async function (sendCmd, apiHost) {\n  if (!apiHost) throw new Error(`Pact.fetch.send(): No apiHost provided`);\n  const sendCmds = asArray(sendCmd).map(cmd => {\n    if (cmd.type === \"cont\") {\n      return prepareContCmd(cmd.keyPairs, cmd.nonce, cmd.proof, cmd.pactId, cmd.rollback, cmd.step, cmd.envData, cmd.meta, cmd.networkId);\n    } else {\n      return prepareExecCmd(cmd.keyPairs, cmd.nonce, cmd.pactCode, cmd.envData, cmd.meta, cmd.networkId);\n    }\n  });\n  const txRes = await fetch(`${apiHost}/api/v1/send`, mkReq(mkPublicSend(sendCmds)));\n  const tx = await txRes.json();\n  return tx;\n};\n/**\n * A SPV Command Object to Execute in Pact Server.\n * @typedef {Object} spvCmd\n * @property requestKey {string} pactId of the cross-chain transaction\n * @property targetChainId {string} chainId of target chain of the cross-chain transaction\n */\n\n/**\n * Sends request to /spv to fetch SPV proof.\n * @param {spvCmd} spvCmd see spvCmd\n * @param {string} apiHost host running Pact server\n * @return {string} SPV proof received from Pact server.\n */\n\n\nconst fetchSPV = async function (spvCmd, apiHost) {\n  if (!apiHost) throw new Error(`Pact.fetch.spv(): No apiHost provided`);\n  enforceType(spvCmd.targetChainId, \"string\", \"targetChainId\");\n  enforceType(spvCmd.requestKey, \"string\", \"requestKey\");\n  const txRes = await fetch(`${apiHost}/spv`, mkReq(spvCmd));\n  const tx = await txRes.json();\n  return tx;\n};\n/**\n * Sends Local Pact command to a local Pact server and retrieves local tx result.\n * @param {execCmd} localCmd a single cmd to execute locally\n * @param {string} apiHost host running Pact server\n * @return {object} tx result received from pact server.\n */\n\n\nconst fetchLocal = async function (localCmd, apiHost) {\n  if (!apiHost) throw new Error(`Pact.fetch.local(): No apiHost provided`);\n  const {\n    keyPairs,\n    nonce,\n    pactCode,\n    envData,\n    meta,\n    networkId\n  } = localCmd;\n  const cmd = prepareExecCmd(keyPairs, nonce, pactCode, envData, meta, networkId);\n  const txRes = await fetch(`${apiHost}/api/v1/local`, mkReq(cmd));\n  const tx = await txRes.json();\n  return tx;\n};\n/**\n * Poll result of Pact command on a Pact server and retrieve tx result.\n * @param {{requestKeys: [<rk:string>]}} pollCmd request Keys of txs to poll.\n * @param {string} apiHost host running Pact server\n * @return {object} Array of tx request keys and tx results from pact server.\n */\n\n\nconst fetchPoll = async function (pollCmd, apiHost) {\n  if (!apiHost) throw new Error(`Pact.fetch.poll(): No apiHost provided`);\n  const res = await fetch(`${apiHost}/api/v1/poll`, mkReq(pollCmd));\n  const resJSON = await res.json();\n  return resJSON;\n};\n/**\n * Listen for result of Pact command on a Pact server and retrieve tx result.\n * @param {{listenCmd: <rk:string>}} listenCmd reqest key of tx to listen.\n * @param {string} apiHost host running Pact server\n * @return {object} Object containing tx result from pact server\n */\n\n\nconst fetchListen = async function (listenCmd, apiHost) {\n  if (!apiHost) throw new Error(`Pact.fetch.listen(): No apiHost provided`);\n  const res = await fetch(`${apiHost}/api/v1/listen`, mkReq(listenCmd));\n  const resJSON = await res.json();\n  return resJSON;\n};\n/**\n  Signing API functions to interact with Chainweaver wallet (https://github.com/kadena-io/chainweaver) and its signing API.\n */\n\n/**\n * Prepares a capability object to be signed with keyPairs using signing API.\n * @param role {string} role of the pact capability\n * @param description {string} description of the pact capability\n * @param name {string} name of pact capability to be signed\n * @param args {array} array of arguments used in pact capability, default to empty array.\n * @return {object} A properly formatted cap object required in signingCmd\n */\n\n\nvar mkCap = function (role, description, name, args = []) {\n  enforceType(role, \"string\", \"role\");\n  enforceType(description, \"string\", \"description\");\n  enforceType(name, \"string\", \"name of capability\");\n  enforceType(args, \"object\", \"arguments to capability\");\n  return {\n    role: role,\n    description: description,\n    cap: {\n      name: name,\n      args: args\n    }\n  };\n};\n/**\n * A signingCmd Object to send to signing API\n * @typedef {Object} signingCmd - cmd to send to signing API\n * @property pactCode {string} - Pact code to execute - required\n * @property caps {array or object} - Pact capability to be signed, see mkCap - required\n * @property envData {object} - JSON of data in command - optional\n * @property sender {string} - sender field in meta, see mkMeta - optional\n * @property chainId {string} - chainId field in meta, see mkMeta - optional\n * @property gasLimit {number} - gasLimit field in meta, see mkMeta - optional\n * @property nonce {string} - nonce value for ensuring unique hash - optional\n **/\n\n/**\n * Sends parameters of Pact Command to the Chainweaver signing API and retrieves a signed Pact Command.\n * @param signingCmd - cmd to be sent to signing API\n * @return {object} valid pact ExecCmd for send or local use.\n **/\n\n\nconst signWallet = async function (signingCmd) {\n  if (!signingCmd.pactCode) throw new Error(`Pact.wallet.sign(): No Pact Code provided`);\n  if (!signingCmd.caps) throw new Error(`Pact.wallet.sign(): No Caps provided`);\n  enforceType(signingCmd.pactCode, \"string\", \"pactCode\");\n  enforceType(signingCmd.caps, \"object\", \"caps\");\n  if (signingCmd.envData) enforceType(signingCmd.envData, \"object\", \"envData\");\n  if (signingCmd.sender) enforceType(signingCmd.sender, \"string\", \"sender\");\n  if (signingCmd.chainId) enforceType(signingCmd.chainId, \"string\", \"chainId\");\n  if (signingCmd.gasLimit) enforceType(signingCmd.gasLimit, \"number\", \"gasLimit\");\n  if (signingCmd.nonce) enforceType(signingCmd.nonce, \"string\", \"nonce\");\n  if (signingCmd.ttl) enforceType(signingCmd.ttl, \"number\", \"ttl\");\n  const cmd = {\n    code: signingCmd.pactCode,\n    caps: asArray(signingCmd.caps),\n    data: signingCmd.envData,\n    sender: signingCmd.sender,\n    chainId: signingCmd.chainId,\n    gasLimit: signingCmd.gasLimit,\n    nonce: signingCmd.nonce,\n    ttl: signingCmd.ttl\n  };\n  const res = await fetch('http://127.0.0.1:9467/v1/sign', mkReq(cmd));\n  const resJSON = await res.json();\n  return resJSON.body;\n};\n/**\n * Sends a signed Pact ExecCmd to a running Pact server and retrieves tx result.\n * @param {signedCmd} valid pact API command for send or local use.\n * @param {string} apiHost host running Pact server\n * @return {object} Request key of the tx received from pact server.\n */\n\n\nconst sendSigned = async function (signedCmd, apiHost) {\n  const cmd = {\n    \"cmds\": [signedCmd]\n  };\n  const txRes = await fetch(`${apiHost}/api/v1/send`, mkReq(cmd));\n  const tx = await txRes.json();\n  return tx;\n};\n\nmodule.exports = {\n  crypto: {\n    binToHex: binToHex,\n    hexToBin: hexToBin,\n    base64UrlEncode: base64UrlEncode,\n    hash: hash,\n    genKeyPair: genKeyPair,\n    sign: sign,\n    toTweetNaclSecretKey: toTweetNaclSecretKey\n  },\n  api: {\n    prepareContCmd: prepareContCmd,\n    prepareExecCmd: prepareExecCmd,\n    mkSingleCmd: mkSingleCmd,\n    mkPublicSend: mkPublicSend\n  },\n  lang: {\n    mkExp: mkExp,\n    mkMeta: mkMeta,\n    mkCap: mkCap\n  },\n  simple: {\n    cont: {\n      createCommand: simpleContCommand\n    },\n    exec: {\n      createCommand: simpleExecCommand,\n      createLocalCommand: prepareExecCmd,\n      createPollRequest: simplePollRequestFromExec,\n      createListenRequest: simpleListenRequestFromExec\n    }\n  },\n  fetch: {\n    send: fetchSend,\n    local: fetchLocal,\n    poll: fetchPoll,\n    listen: fetchListen,\n    spv: fetchSPV\n  },\n  wallet: {\n    sign: signWallet,\n    sendSigned: sendSigned\n  }\n};","map":{"version":3,"sources":["/Users/francescomelpignano/Desktop/kadena/code/covid19-dashboard/node_modules/pact-lang-api/pact-lang-api.js"],"names":["blake","require","nacl","base64url","fetch","binToHex","s","constructor","name","TypeError","Buffer","from","toString","hexToBin","h","Uint8Array","hashBin","blake2b","hash","base64UrlEncode","escape","encode","genKeyPair","kp","sign","keyPair","pubKey","publicKey","secKey","secretKey","slice","toTweetNaclSecretKey","hasOwnProperty","JSON","stringify","msg","hshBin","hsh","sig","undefined","sigBin","detached","pullAndCheckHashs","sigs","i","length","Error","prepareExecCmd","keyPairs","nonce","Date","toISOString","pactCode","envData","meta","mkMeta","networkId","enforceType","kpArray","asArray","filter","signers","map","mkSigner","cmdJSON","payload","exec","data","code","cmd","mkSingleCmd","prepareContCmd","proof","pactId","rollback","step","cont","enforceArray","mkPublicSend","cmds","clist","singleOrArray","Array","isArray","val","type","simpleExecCommand","simpleContCommand","unique","arr","n","r","push","simplePollRequestFromExec","execMsg","rks","every","v","requestKeys","simpleListenRequestFromExec","listen","mkExp","pgmName","prototype","call","arguments","join","sender","chainId","gasPrice","gasLimit","creationTime","ttl","mkReq","headers","method","body","fetchSend","sendCmd","apiHost","sendCmds","txRes","tx","json","fetchSPV","spvCmd","targetChainId","requestKey","fetchLocal","localCmd","fetchPoll","pollCmd","res","resJSON","fetchListen","listenCmd","mkCap","role","description","args","cap","signWallet","signingCmd","caps","sendSigned","signedCmd","module","exports","crypto","api","lang","simple","createCommand","createLocalCommand","createPollRequest","createListenRequest","send","local","poll","spv","wallet"],"mappings":"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","sourcesContent":["/** pact-lang-api.js\n * Exports functions to support Pact API calls.\n * Author: Will Martino, Hee Kyun Yun, Stuart Popejoy\n * Supports: Pact API 3.0 v1\n */\n\nconst blake = require(\"blakejs\");\nconst nacl = require(\"tweetnacl\");\nconst base64url = require(\"base64-url\");\nconst fetch = require(\"node-fetch\");\n\n/**\n * Convert binary to hex.\n * @param s {Uint8Array} - binary value\n * @return {string} hex string\n */\nvar binToHex = function(s) {\n  var constructor = s.constructor.name || null;\n\n  if (constructor !== \"Uint8Array\") {\n    throw new TypeError(\"Expected Uint8Array\");\n  }\n\n  return Buffer.from(s).toString(\"hex\");\n};\n\n/**\n * Convert hex string to binary.\n * @param s {string} - hex string\n * @return {Uint8Array} binary value\n */\nvar hexToBin = function(h) {\n  if (typeof h !== \"string\") {\n    throw new TypeError(\"Expected string: \" + h);\n  }\n  return new Uint8Array(Buffer.from(h, \"hex\"));\n};\n\n/**\n * Perform blake2b256 hashing.\n */\nvar hashBin = function(s) {\n  return blake.blake2b(s, null, 32);\n};\n\n/**\n * Perform blake2b256 hashing, encoded as unescaped base64url.\n */\nvar hash = function(s) {\n  return base64UrlEncode(hashBin(s));\n};\n\n/**\n * Hash string as unescaped base64url.\n */\nvar base64UrlEncode = function(s) {\n  return base64url.escape(base64url.encode(s));\n};\n\n/**\n * Generate a random ED25519 keypair.\n * @return {object} with \"publicKey\" and \"secretKey\" fields.\n */\nvar genKeyPair = function() {\n  var kp = nacl.sign.keyPair();\n  var pubKey = binToHex(kp.publicKey);\n  var secKey = binToHex(kp.secretKey).slice(0, 64);\n  return { publicKey: pubKey, secretKey: secKey };\n};\n\nvar toTweetNaclSecretKey = function(keyPair) {\n  if (\n    !keyPair.hasOwnProperty(\"publicKey\") ||\n    !keyPair.hasOwnProperty(\"secretKey\")\n  ) {\n    throw new TypeError(\n      \"Invalid KeyPair: expected to find keys of name 'secretKey' and 'publicKey': \" +\n        JSON.stringify(keyPair)\n    );\n  }\n  return hexToBin(keyPair.secretKey + keyPair.publicKey);\n};\n\n/**\n * Sign data using key pair.\n * @param msg - some data to be passed to blake2b256.\n * @param keyPair - signing ED25519 keypair\n * @return {object} with \"hash\", \"sig\" (signature in hex format), and \"pubKey\" public key value.\n */\nvar sign = function(msg, keyPair) {\n  var hshBin = hashBin(msg);\n  var hsh = base64UrlEncode(hshBin);\n  if (\n    !keyPair.hasOwnProperty(\"publicKey\") &&\n    !keyPair.hasOwnProperty(\"secretKey\")\n  ) {\n    return { hash: hsh, sig: undefined };\n  } else if (\n    keyPair.hasOwnProperty(\"publicKey\") &&\n    (!keyPair.hasOwnProperty(\"secretKey\") || !keyPair.secretKey)){\n      return { hash: hsh, sig: \"REPLACE THIS WITH SIGNATURE\" };\n    }\n  var sigBin = nacl.sign.detached(hshBin, toTweetNaclSecretKey(keyPair));\n  return { hash: hsh, sig: binToHex(sigBin) };\n};\n\nvar pullAndCheckHashs = function(sigs) {\n  var hsh = sigs[0].hash;\n  for (var i = 1; i < sigs.length; i++) {\n    if (sigs[i].hash !== hsh) {\n      throw new Error(\n        \"Sigs for different hashes found: \" + JSON.stringify(sigs)\n      );\n    }\n  }\n  return hsh;\n};\n\n/**\n * Prepare an ExecMsg pact command for use in send or local execution.\n * To use in send, wrap result with 'mkSingleCommand'.\n * @param keyPairs {array or object} - array or single ED25519 keypair and/or clist (list of `cap` in mkCap)\n * @param nonce {string} - nonce value for ensuring unique hash - default to current time\n * @param pactCode {string} - pact code to execute - required\n * @param envData {object} - JSON of data in command - not required\n * @param meta {object} - public meta information, see mkMeta\n * @return valid pact API command for send or local use.\n */\nvar prepareExecCmd = function(keyPairs=[], nonce=new Date().toISOString(), pactCode,\n                              envData, meta=mkMeta(\"\",\"\",0,0,0,0), networkId=null) {\n  enforceType(nonce, \"string\", \"nonce\");\n  enforceType(pactCode, \"string\", \"pactCode\");\n  var kpArray = asArray(keyPairs);\n  kpArray = kpArray.filter(kp => !!kp.publicKey)\n  var signers = kpArray.map(mkSigner);\n  var cmdJSON = {\n    networkId: networkId,\n    payload: {\n      exec: {\n        data: envData || {},\n        code: pactCode\n      }\n    },\n    signers: signers,\n    meta: meta,\n    nonce: JSON.stringify(nonce)\n  };\n  var cmd = JSON.stringify(cmdJSON);\n  var sigs = kpArray.length===0\n    ? [sign(cmd, kpArray)]\n    : kpArray.map(kp => sign(cmd, kp));\n  return mkSingleCmd(sigs, cmd);\n};\n\n/**\n * Prepare an ContMsg pact command for use in send or local execution.\n * To use in send, wrap result with 'mkSingleCommand'.\n * @param keyPairs {array or object} - array or single ED25519 keypair and/or clist (list of `cap` in mkCap)\n * @param nonce {string} - nonce value for ensuring unique hash - default to current time\n * @param step {number} - integer index of step to execute in defpact body - required\n * @param proof {string} - JSON of SPV proof, required for cross-chain transfer. See `fetchSPV` below\n * @param rollback {bool} - Indicates if this continuation is a rollback/cancel- required\n * @param pactId {string} - identifies the already-begun Pact execution that this is continuing - required\n * @param envData {object} - JSON of data in command - not required\n * @param meta {object} - public meta information, see mkMeta\n * @return valid pact API Cont command for send or local use.\n */\nvar prepareContCmd = function(keyPairs=[], nonce=new Date().toISOString(),\n                              proof, pactId, rollback, step, envData,\n                              meta=mkMeta(\"\",\"\",0,0,0,0), networkId=null) {\n\n  enforceType(nonce, \"string\", \"nonce\");\n  var kpArray = asArray(keyPairs);\n  var kpArray = asArray(keyPairs);\n  kpArray = kpArray.filter(kp => !!kp.publicKey)\n  var signers = kpArray.map(mkSigner);\n  var cmdJSON = {\n    networkId: networkId,\n    payload: {\n      cont: {\n        proof: proof || null,\n        pactId: pactId,\n        rollback: rollback,\n        step: step,\n        data: envData || {},\n      }\n    },\n    signers: signers,\n    meta: meta,\n    nonce: JSON.stringify(nonce)\n  };\n  var cmd = JSON.stringify(cmdJSON);\n  var sigs = kpArray.map(function(kp) {\n    return sign(cmd, kp);\n  });\n  return mkSingleCmd(sigs, cmd);\n};\n\n/**\n * Makes a single command given signed data.\n * @param sigs {array} - array of signature objects, see 'sign'\n * @param cmd {string} - stringified JSON blob used to create hash\n * @return valid Pact API command for send or local use.\n */\nvar mkSingleCmd = function(sigs, cmd) {\n  enforceArray(sigs, \"sigs\");\n  enforceType(cmd, \"string\", \"cmd\");\n  return {\n    hash: pullAndCheckHashs(sigs),\n    sigs: sigs.filter(s => {\n      if (s.sig===undefined) return false;\n      else return true\n    }).map(s => {\n      return {sig: s.sig}\n    }),\n    cmd: cmd\n  }\n};\n\n/**\n * Makes outer wrapper for a 'send' endpoint.\n * @param {array or object} cmds - one or an array of commands, see mkSingleCmd\n */\nvar mkPublicSend = function(cmds) {\n  return { cmds: asArray(cmds) };\n};\n\n/**\n * Make an ED25519 \"signer\" array element for inclusion in a Pact payload.\n * @param {object} kp - a ED25519 keypair and/or clist (list of `cap` in mkCap)\n * @return {object} an object with pubKey, addr and scheme fields.\n */\nvar mkSigner = function(kp) {\n  return {\n    clist: kp.clist ? asArray(kp.clist) : [],\n    pubKey: kp.publicKey\n  };\n};\n\nvar asArray = function(singleOrArray) {\n  if (Array.isArray(singleOrArray)) {\n    return singleOrArray;\n  } else {\n    return [singleOrArray];\n  }\n};\n\nvar enforceType = function(val, type, msg) {\n  if (typeof val !== type) {\n    throw new TypeError(\n      msg + \" must be a \" + type + \": \" + JSON.stringify(val)\n    );\n  }\n};\n\nvar enforceArray = function(val, msg) {\n  if (!Array.isArray(val)) {\n    throw new TypeError(msg + \" must be an array: \" + JSON.stringify(val));\n  }\n};\n\n/**\n * Make a full 'send' endpoint exec command. See 'prepareExecCmd' for parameters.\n */\nvar simpleExecCommand = function(keyPairs, nonce, pactCode, envData, meta, networkId) {\n  return mkPublicSend(prepareExecCmd(keyPairs, nonce, pactCode, envData, meta, networkId));\n};\n\n/**\n * Make a full 'send' endpoint cont command. See 'prepareContCmd' for parameters.\n */\nvar simpleContCommand = function(keyPairs, nonce, step, pactId, rollback, envData, meta, proof, networkId) {\n  return mkPublicSend(prepareContCmd(keyPairs, nonce, proof, pactId, rollback, step, envData, meta, networkId));\n};\n\nvar unique = function(arr) {\n  var n = {},\n    r = [];\n  for (var i = 0; i < arr.length; i++) {\n    if (!n[arr[i]]) {\n      n[arr[i]] = true;\n      r.push(arr[i]);\n    }\n  }\n  return r;\n};\n\n/**\n * Given an exec 'send' message, prepare a message for 'poll' endpoint.\n * @param execMsg {object} JSON with \"cmds\" field, see 'mkPublicSend'\n * @return {object} with \"requestKeys\" for polling.\n */\nvar simplePollRequestFromExec = function(execMsg) {\n  var cmds =\n    execMsg.cmds ||\n    TypeError(\"expected key 'cmds' in object: \" + JSON.stringify(execMsg));\n  var rks = [];\n  if (\n    !cmds.every(function(v) {\n      return v.hasOwnProperty(\"hash\");\n    })\n  ) {\n    throw new TypeError(\n      'maleformed object, expected \"hash\" key in every cmd: ' +\n        JSON.stringify(execMsg)\n    );\n  } else {\n    rks = unique(\n      cmds.map(function(v) {\n        return v.hash;\n      })\n    );\n  }\n  return { requestKeys: rks };\n};\n\n/**\n * Given an exec 'send' message, prepare a message for 'listen' endpoint.\n * @param execMsg {object} JSON with \"cmds\" field, see 'mkPublicSend'. Only takes first element.\n * @return {object} with \"requestKey\" for polling.\n */\nvar simpleListenRequestFromExec = function(execMsg) {\n  var cmds =\n    execMsg.cmds ||\n    TypeError(\"expected key 'cmds' in object: \" + JSON.stringify(execMsg));\n  var rks = [];\n  if (\n    !cmds.every(function(v) {\n      return v.hasOwnProperty(\"hash\");\n    })\n  ) {\n    throw new TypeError(\n      'maleformed object, expected \"hash\" key in every cmd: ' +\n        JSON.stringify(execMsg)\n    );\n  } else {\n    rks = unique(\n      cmds.map(function(v) {\n        return v.hash;\n      })\n    );\n  }\n  return { listen: rks[0] };\n};\n\n/**\n * Variadic function to form a lisp s-expression application.\n * Encases arguments in parens and intercalates with a space.\n */\nvar mkExp = function(pgmName) {\n  enforceType(pgmName, \"string\", \"pgmName\");\n  return (\n    \"(\" +\n    pgmName +\n    \" \" +\n    Array.prototype.slice\n      .call(arguments, 1)\n      .map(JSON.stringify)\n      .join(\" \") +\n    \")\"\n  );\n};\n\n/**\n * Prepare a chainweb-style public meta payload.\n * @param sender {string} gas account\n * @param chainId {string} chain identifier\n * @param gasPrice {number} desired gas price\n * @param gasLimit {number} desired gas limit\n * @param creationTime {number} desired tx's time created in UNIX epoch time as seconds\n * @param ttl {number} desired tx's time to live as seconds\n * @return {object} of arguments, type-checked and properly named.\n */\nvar mkMeta = function(sender, chainId, gasPrice, gasLimit, creationTime, ttl) {\n  enforceType(sender, \"string\", \"sender\");\n  enforceType(chainId, \"string\", \"chainId\");\n  enforceType(gasPrice, \"number\", \"gasPrice\");\n  enforceType(gasLimit, \"number\", \"gasLimit\");\n  enforceType(creationTime, \"number\", \"creationTime\");\n  enforceType(ttl,  \"number\", \"ttl\");\n  return {\n    creationTime: creationTime,\n    ttl: ttl,\n    gasLimit: gasLimit,\n    chainId: chainId,\n    gasPrice: gasPrice,\n    sender: sender\n  };\n};\n\n/**\n * Formats ExecCmd into api request object\n */\nvar mkReq = function(cmd) {\n  return {\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    method: \"POST\",\n    body: JSON.stringify(cmd)\n  };\n};\n\n\n\n /**\n  * An execCmd Object to Execute in send or local.\n  * @typedef {Object} cmd to `/send` endpoint\n  * @property type {string} - type of command - \"cont\" or \"exec\", default to \"exec\"\n  * @property pactCode {string} - pact code to execute in \"exec\" command - required for \"exec\"\n  * @property nonce {string} - nonce value to ensure unique hash - default to current time\n  * @property envData {object} - JSON of data in command - not required\n  * @property meta {object} - public meta information, see mkMeta\n  * @property networkId {object} network identifier of where the cmd is executed.\n  */\n\n /**\n  * A contCmd to Execute in send\n  * @typedef {Object} cmd to `/send` endpoint\n  * @property type {string} - type of command - \"cont\" or \"exec\", default to \"exec\"\n  * @property pactId {string} - pactId the cont command - required for \"cont\"\n  * @property nonce {string} - nonce value to ensure unique hash - default to current time\n  * @property step {number} - the step of the mutli-step transaction - required for \"cont\"\n  * @property proof {string} - JSON of SPV proof, required for cross-chain transfer. See `fetchSPV` below\n  * @property rollback {bool} - Indicates if this continuation is a rollback/cancel - required for \"cont\"\n  * @property envData {object} - JSON of data in command - not required\n  * @property meta {object} - public meta information, see mkMeta\n  * @property networkId {object} network identifier of where the cmd is executed.\n  */\n\n/**\n * Sends Pact command to a running Pact server and retrieves tx result.\n * @param {[execCmd or contCmd] or execCmd or contCmd} cmd or a list of cmds to execute\n * @param {string} apiHost host running Pact server\n * @return {object} Request key of the tx received from pact server.\n */\nconst fetchSend = async function(sendCmd, apiHost){\n  if (!apiHost)  throw new Error(`Pact.fetch.send(): No apiHost provided`);\n  const sendCmds = asArray(sendCmd).map(cmd => {\n    if (cmd.type === \"cont\") {\n      return prepareContCmd( cmd.keyPairs, cmd.nonce, cmd.proof, cmd.pactId,\n                             cmd.rollback, cmd.step, cmd.envData, cmd.meta,\n                             cmd.networkId )\n    } else {\n      return prepareExecCmd( cmd.keyPairs, cmd.nonce, cmd.pactCode,\n                             cmd.envData, cmd.meta, cmd.networkId )\n    }\n  })\n  const txRes = await fetch(`${apiHost}/api/v1/send`, mkReq(mkPublicSend(sendCmds)));\n  const tx = await txRes.json();\n  return tx;\n};\n\n/**\n * A SPV Command Object to Execute in Pact Server.\n * @typedef {Object} spvCmd\n * @property requestKey {string} pactId of the cross-chain transaction\n * @property targetChainId {string} chainId of target chain of the cross-chain transaction\n */\n\n/**\n * Sends request to /spv to fetch SPV proof.\n * @param {spvCmd} spvCmd see spvCmd\n * @param {string} apiHost host running Pact server\n * @return {string} SPV proof received from Pact server.\n */\nconst fetchSPV = async function(spvCmd, apiHost){\n  if (!apiHost)  throw new Error(`Pact.fetch.spv(): No apiHost provided`);\n  enforceType(spvCmd.targetChainId, \"string\", \"targetChainId\");\n  enforceType(spvCmd.requestKey, \"string\", \"requestKey\");\n  const txRes = await fetch(`${apiHost}/spv`, mkReq(spvCmd));\n  const tx = await txRes.json();\n  return tx;\n};\n\n/**\n * Sends Local Pact command to a local Pact server and retrieves local tx result.\n * @param {execCmd} localCmd a single cmd to execute locally\n * @param {string} apiHost host running Pact server\n * @return {object} tx result received from pact server.\n */\nconst fetchLocal = async function(localCmd, apiHost) {\n  if (!apiHost)  throw new Error(`Pact.fetch.local(): No apiHost provided`);\n  const {keyPairs, nonce, pactCode, envData, meta, networkId} = localCmd\n  const cmd = prepareExecCmd(keyPairs, nonce, pactCode, envData, meta, networkId);\n  const txRes = await fetch(`${apiHost}/api/v1/local`, mkReq(cmd));\n  const tx = await txRes.json();\n  return tx;\n};\n\n/**\n * Poll result of Pact command on a Pact server and retrieve tx result.\n * @param {{requestKeys: [<rk:string>]}} pollCmd request Keys of txs to poll.\n * @param {string} apiHost host running Pact server\n * @return {object} Array of tx request keys and tx results from pact server.\n */\nconst fetchPoll = async function(pollCmd, apiHost) {\n  if (!apiHost)  throw new Error(`Pact.fetch.poll(): No apiHost provided`);\n  const res = await fetch(`${apiHost}/api/v1/poll`, mkReq(pollCmd));\n  const resJSON = await res.json();\n  return resJSON;\n};\n\n/**\n * Listen for result of Pact command on a Pact server and retrieve tx result.\n * @param {{listenCmd: <rk:string>}} listenCmd reqest key of tx to listen.\n * @param {string} apiHost host running Pact server\n * @return {object} Object containing tx result from pact server\n */\n const fetchListen = async function(listenCmd, apiHost) {\n   if (!apiHost)  throw new Error(`Pact.fetch.listen(): No apiHost provided`);\n   const res = await fetch(`${apiHost}/api/v1/listen`, mkReq(listenCmd));\n   const resJSON = await res.json();\n   return resJSON;\n };\n\n/**\n  Signing API functions to interact with Chainweaver wallet (https://github.com/kadena-io/chainweaver) and its signing API.\n */\n\n/**\n * Prepares a capability object to be signed with keyPairs using signing API.\n * @param role {string} role of the pact capability\n * @param description {string} description of the pact capability\n * @param name {string} name of pact capability to be signed\n * @param args {array} array of arguments used in pact capability, default to empty array.\n * @return {object} A properly formatted cap object required in signingCmd\n */\nvar mkCap = function(role, description, name, args=[]) {\n  enforceType(role, \"string\", \"role\");\n  enforceType(description, \"string\", \"description\");\n  enforceType(name, \"string\", \"name of capability\");\n  enforceType(args, \"object\", \"arguments to capability\");\n  return {\n    role: role,\n    description: description,\n    cap: {\n      name: name,\n      args: args\n    }\n  };\n};\n\n/**\n * A signingCmd Object to send to signing API\n * @typedef {Object} signingCmd - cmd to send to signing API\n * @property pactCode {string} - Pact code to execute - required\n * @property caps {array or object} - Pact capability to be signed, see mkCap - required\n * @property envData {object} - JSON of data in command - optional\n * @property sender {string} - sender field in meta, see mkMeta - optional\n * @property chainId {string} - chainId field in meta, see mkMeta - optional\n * @property gasLimit {number} - gasLimit field in meta, see mkMeta - optional\n * @property nonce {string} - nonce value for ensuring unique hash - optional\n **/\n\n/**\n * Sends parameters of Pact Command to the Chainweaver signing API and retrieves a signed Pact Command.\n * @param signingCmd - cmd to be sent to signing API\n * @return {object} valid pact ExecCmd for send or local use.\n **/\n const signWallet = async function (signingCmd){\n   if (!signingCmd.pactCode) throw new Error(`Pact.wallet.sign(): No Pact Code provided`);\n   if (!signingCmd.caps) throw new Error(`Pact.wallet.sign(): No Caps provided`);\n   enforceType(signingCmd.pactCode, \"string\", \"pactCode\");\n   enforceType(signingCmd.caps, \"object\", \"caps\");\n   if (signingCmd.envData) enforceType(signingCmd.envData, \"object\", \"envData\");\n   if (signingCmd.sender) enforceType(signingCmd.sender, \"string\", \"sender\");\n   if (signingCmd.chainId) enforceType(signingCmd.chainId, \"string\", \"chainId\");\n   if (signingCmd.gasLimit) enforceType(signingCmd.gasLimit, \"number\", \"gasLimit\");\n   if (signingCmd.nonce) enforceType(signingCmd.nonce, \"string\", \"nonce\");\n   if (signingCmd.ttl) enforceType(signingCmd.ttl, \"number\", \"ttl\");\n\n   const cmd = {\n     code: signingCmd.pactCode,\n     caps: asArray(signingCmd.caps),\n     data: signingCmd.envData,\n     sender: signingCmd.sender,\n     chainId: signingCmd.chainId,\n     gasLimit: signingCmd.gasLimit,\n     nonce: signingCmd.nonce,\n     ttl: signingCmd.ttl\n   }\n   const res = await fetch('http://127.0.0.1:9467/v1/sign', mkReq(cmd))\n   const resJSON = await res.json();\n   return resJSON.body;\n }\n\n/**\n * Sends a signed Pact ExecCmd to a running Pact server and retrieves tx result.\n * @param {signedCmd} valid pact API command for send or local use.\n * @param {string} apiHost host running Pact server\n * @return {object} Request key of the tx received from pact server.\n */\nconst sendSigned = async function (signedCmd, apiHost) {\n  const cmd = {\n    \"cmds\": [ signedCmd ]\n  }\n  const txRes = await fetch(`${apiHost}/api/v1/send`, mkReq(cmd));\n  const tx = await txRes.json();\n  return tx;\n}\n\nmodule.exports = {\n  crypto: {\n    binToHex: binToHex,\n    hexToBin: hexToBin,\n    base64UrlEncode: base64UrlEncode,\n    hash: hash,\n    genKeyPair: genKeyPair,\n    sign: sign,\n    toTweetNaclSecretKey: toTweetNaclSecretKey\n  },\n  api: {\n    prepareContCmd: prepareContCmd,\n    prepareExecCmd: prepareExecCmd,\n    mkSingleCmd: mkSingleCmd,\n    mkPublicSend: mkPublicSend\n  },\n  lang: {\n    mkExp: mkExp,\n    mkMeta: mkMeta,\n    mkCap: mkCap\n  },\n  simple: {\n    cont: {\n      createCommand: simpleContCommand\n    },\n    exec: {\n      createCommand: simpleExecCommand,\n      createLocalCommand: prepareExecCmd,\n      createPollRequest: simplePollRequestFromExec,\n      createListenRequest: simpleListenRequestFromExec\n    }\n  },\n  fetch: {\n    send: fetchSend,\n    local: fetchLocal,\n    poll: fetchPoll,\n    listen: fetchListen,\n    spv: fetchSPV\n  },\n  wallet: {\n    sign: signWallet,\n    sendSigned: sendSigned\n  }\n};\n"]},"metadata":{},"sourceType":"script"}