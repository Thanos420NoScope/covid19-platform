"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const file_type_1 = __importDefault(require("file-type"));
const jpeg_js_1 = __importDefault(require("jpeg-js"));
const pngjs_1 = require("pngjs");
const request_1 = __importDefault(require("request"));
const block_hash_1 = __importDefault(require("./block-hash"));
const url_1 = require("url");
const processPNG = (data, bits, method, cb) => {
    try {
        const png = pngjs_1.PNG.sync.read(data);
        const res = block_hash_1.default(png, bits, method ? 2 : 1);
        cb(null, res);
    }
    catch (e) {
        cb(e);
    }
};
const processJPG = (data, bits, method, cb) => {
    try {
        const decoded = jpeg_js_1.default.decode(data);
        const res = block_hash_1.default(decoded, bits, method ? 2 : 1);
        cb(null, res);
    }
    catch (e) {
        cb(e);
    }
};
// eslint-disable-next-line
exports.imageHash = (oldSrc, bits, method, cb) => {
    const src = oldSrc;
    const checkFileType = (name, data) => {
        // what is the image type
        const type = file_type_1.default(data);
        if (!type || !type.mime) {
            cb(new Error('Mime type not found'));
            return;
        }
        if (name.lastIndexOf('.') > 0) {
            const ext = name
                .split('.')
                .pop()
                .toLowerCase();
            if (ext === 'png' && type.mime === 'image/png') {
                processPNG(data, bits, method, cb);
            }
            else if ((ext === 'jpg' || ext === 'jpeg') && type.mime === 'image/jpeg') {
                processJPG(data, bits, method, cb);
            }
            else {
                cb(new Error(`Unrecognized file extension, mime type or mismatch, ext: ${ext} / mime: ${type.mime}`));
            }
        }
        else {
            console.warn('No file extension found, attempting mime typing.');
            if (type.mime === 'image/png') {
                processPNG(data, bits, method, cb);
            }
            else if (type.mime === 'image/jpeg') {
                processJPG(data, bits, method, cb);
            }
            else {
                cb(new Error(`Unrecognized mime type: ${type.mime}`));
            }
        }
    };
    const handleRequest = (err, res) => {
        if (err) {
            cb(new Error(err));
        }
        else {
            const url = new url_1.URL(res.request.uri.href);
            const name = url.pathname;
            checkFileType(name, res.body);
        }
    };
    const handleReadFile = (err, res) => {
        if (err) {
            cb(new Error(err));
            return;
        }
        checkFileType(src, res);
    };
    // check source
    // is source assigned
    if (src === undefined) {
        cb(new Error('No image source provided'));
        return;
    }
    // is src url or file
    if (typeof src === 'string' && src.indexOf('http') === 0) {
        // url
        const req = {
            url: src,
            encoding: null,
        };
        request_1.default(req, handleRequest);
    }
    else if (typeof src === 'object') {
        // Request Object
        src.encoding = null;
        request_1.default(src, handleRequest);
    }
    else {
        // file
        fs_1.default.readFile(src, handleReadFile);
    }
};
//# sourceMappingURL=imageHash.js.map