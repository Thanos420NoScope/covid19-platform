{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst date_fns_1 = require('date-fns');\n\nconst MILLISECONDS_IN_HOUR = 3600000;\nconst MILLISECONDS_IN_MINUTE = 60000;\nconst DEFAULT_ADDITIONAL_DIGITS = 2;\nconst parseTokenDateTimeDelimeter = /[T ]/;\nconst parseTokenPlainTime = /:/; // year tokens\n\nconst parseTokenYY = /^(\\d{2})$/;\nconst parseTokensYYY = [/^([+-]\\d{2})$/, /^([+-]\\d{3})$/, /^([+-]\\d{4})$/ // 2 additional digits\n];\nconst parseTokenYYYY = /^(\\d{4})/;\nconst parseTokensYYYYY = [/^([+-]\\d{4})/, /^([+-]\\d{5})/, /^([+-]\\d{6})/ // 2 additional digits\n]; // date tokens\n\nconst parseTokenMM = /^-(\\d{2})$/;\nconst parseTokenDDD = /^-?(\\d{3})$/;\nconst parseTokenMMDD = /^-?(\\d{2})-?(\\d{2})$/;\nconst parseTokenWww = /^-?W(\\d{2})$/;\nconst parseTokenWwwD = /^-?W(\\d{2})-?(\\d{1})$/; // time tokens\n\nconst parseTokenHH = /^(\\d{2}([.,]\\d*)?)$/;\nconst parseTokenHHMM = /^(\\d{2}):?(\\d{2}([.,]\\d*)?)$/;\nconst parseTokenHHMMSS = /^(\\d{2}):?(\\d{2}):?(\\d{2}([.,]\\d*)?)$/; // timezone tokens\n\nconst parseTokenTimezone = /([Z+-].*)$/;\nconst parseTokenTimezoneZ = /^(Z)$/;\nconst parseTokenTimezoneHH = /^([+-])(\\d{2})$/;\nconst parseTokenTimezoneHHMM = /^([+-])(\\d{2}):?(\\d{2})$/;\n\nfunction legacyParse(argument, options = {}) {\n  if (date_fns_1.isDate(argument)) {\n    // Prevent the date to lose the milliseconds when passed to new Date() in IE10\n    return new Date(argument.getTime());\n  } else if (typeof argument !== 'string') {\n    return new Date(argument);\n  }\n\n  const additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : Number(options.additionalDigits);\n  const dateStrings = splitDateString(argument);\n  const parseYearResult = parseYear(dateStrings.date || '', additionalDigits);\n  const year = parseYearResult.year;\n  const restDateString = parseYearResult.restDateString;\n  const date = parseDate(restDateString || '', year);\n\n  if (date) {\n    const timestamp = date.getTime();\n    let time = 0;\n    let offset;\n\n    if (dateStrings.time) {\n      time = parseTime(dateStrings.time) || 0;\n    }\n\n    if (dateStrings.timezone) {\n      offset = parseTimezone(dateStrings.timezone) * MILLISECONDS_IN_MINUTE;\n    } else {\n      const fullTime = timestamp + time;\n      const fullTimeDate = new Date(fullTime);\n      offset = getTimezoneOffsetInMilliseconds(fullTimeDate); // Adjust time when it's coming from DST\n\n      const fullTimeDateNextDay = new Date(fullTime);\n      fullTimeDateNextDay.setDate(fullTimeDate.getDate() + 1);\n      const offsetDiff = getTimezoneOffsetInMilliseconds(fullTimeDateNextDay) - getTimezoneOffsetInMilliseconds(fullTimeDate);\n\n      if (offsetDiff > 0) {\n        offset += offsetDiff;\n      }\n    }\n\n    return new Date(timestamp + time + offset);\n  } else {\n    return new Date(argument);\n  }\n}\n\nexports.default = legacyParse;\n\nfunction splitDateString(dateString) {\n  const array = dateString.split(parseTokenDateTimeDelimeter);\n  let timeString, date, time, timezone;\n\n  if (parseTokenPlainTime.test(array[0])) {\n    date = undefined;\n    timeString = array[0];\n  } else {\n    date = array[0];\n    timeString = array[1];\n  }\n\n  if (timeString) {\n    const token = parseTokenTimezone.exec(timeString);\n\n    if (token) {\n      time = timeString.replace(token[1], '');\n      timezone = token[1];\n    } else {\n      time = timeString;\n    }\n  }\n\n  return {\n    date,\n    time,\n    timezone\n  };\n}\n\nfunction parseYear(dateString, additionalDigits) {\n  const parseTokenYYY = parseTokensYYY[additionalDigits];\n  const parseTokenYYYYY = parseTokensYYYYY[additionalDigits];\n  let token; // YYYY or ±YYYYY\n\n  token = parseTokenYYYY.exec(dateString) || parseTokenYYYYY.exec(dateString);\n\n  if (token) {\n    const yearString = token[1];\n    return {\n      year: parseInt(yearString, 10),\n      restDateString: dateString.slice(yearString.length)\n    };\n  } // YY or ±YYY\n\n\n  token = parseTokenYY.exec(dateString) || parseTokenYYY.exec(dateString);\n\n  if (token) {\n    const centuryString = token[1];\n    return {\n      year: parseInt(centuryString, 10) * 100,\n      restDateString: dateString.slice(centuryString.length)\n    };\n  } // Invalid ISO-formatted year\n\n\n  return {\n    year: null\n  };\n}\n\nfunction parseDate(dateString, year) {\n  // Invalid ISO-formatted year\n  if (year === null) {\n    return null;\n  }\n\n  let token;\n  let date;\n  let month;\n  let week; // YYYY\n\n  if (dateString.length === 0) {\n    date = new Date(0);\n    date.setUTCFullYear(year);\n    return date;\n  } // YYYY-MM\n\n\n  token = parseTokenMM.exec(dateString);\n\n  if (token) {\n    date = new Date(0);\n    month = parseInt(token[1], 10) - 1;\n    date.setUTCFullYear(year, month);\n    return date;\n  } // YYYY-DDD or YYYYDDD\n\n\n  token = parseTokenDDD.exec(dateString);\n\n  if (token) {\n    date = new Date(0);\n    const dayOfYear = parseInt(token[1], 10);\n    date.setUTCFullYear(year, 0, dayOfYear);\n    return date;\n  } // YYYY-MM-DD or YYYYMMDD\n\n\n  token = parseTokenMMDD.exec(dateString);\n\n  if (token) {\n    date = new Date(0);\n    month = parseInt(token[1], 10) - 1;\n    const day = parseInt(token[2], 10);\n    date.setUTCFullYear(year, month, day);\n    return date;\n  } // YYYY-Www or YYYYWww\n\n\n  token = parseTokenWww.exec(dateString);\n\n  if (token) {\n    week = parseInt(token[1], 10) - 1;\n    return dayOfISOYear(year, week);\n  } // YYYY-Www-D or YYYYWwwD\n\n\n  token = parseTokenWwwD.exec(dateString);\n\n  if (token) {\n    week = parseInt(token[1], 10) - 1;\n    const dayOfWeek = parseInt(token[2], 10) - 1;\n    return dayOfISOYear(year, week, dayOfWeek);\n  } // Invalid ISO-formatted date\n\n\n  return null;\n}\n\nfunction parseTime(timeString) {\n  let token;\n  let hours;\n  let minutes; // hh\n\n  token = parseTokenHH.exec(timeString);\n\n  if (token) {\n    hours = parseFloat(token[1].replace(',', '.'));\n    return hours % 24 * MILLISECONDS_IN_HOUR;\n  } // hh:mm or hhmm\n\n\n  token = parseTokenHHMM.exec(timeString);\n\n  if (token) {\n    hours = parseInt(token[1], 10);\n    minutes = parseFloat(token[2].replace(',', '.'));\n    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;\n  } // hh:mm:ss or hhmmss\n\n\n  token = parseTokenHHMMSS.exec(timeString);\n\n  if (token) {\n    hours = parseInt(token[1], 10);\n    minutes = parseInt(token[2], 10);\n    const seconds = parseFloat(token[3].replace(',', '.'));\n    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000;\n  } // Invalid ISO-formatted time\n\n\n  return null;\n}\n\nfunction parseTimezone(timezoneString) {\n  let token;\n  let absoluteOffset; // Z\n\n  token = parseTokenTimezoneZ.exec(timezoneString);\n\n  if (token) {\n    return 0;\n  } // ±hh\n\n\n  token = parseTokenTimezoneHH.exec(timezoneString);\n\n  if (token) {\n    absoluteOffset = parseInt(token[2], 10) * 60;\n    return token[1] === '+' ? -absoluteOffset : absoluteOffset;\n  } // ±hh:mm or ±hhmm\n\n\n  token = parseTokenTimezoneHHMM.exec(timezoneString);\n\n  if (token) {\n    absoluteOffset = parseInt(token[2], 10) * 60 + parseInt(token[3], 10);\n    return token[1] === '+' ? -absoluteOffset : absoluteOffset;\n  }\n\n  return 0;\n}\n\nfunction dayOfISOYear(isoYear, week = 0, day = 0) {\n  const date = new Date(0);\n  date.setUTCFullYear(isoYear, 0, 4);\n  const fourthOfJanuaryDay = date.getUTCDay() || 7;\n  const diff = week * 7 + day + 1 - fourthOfJanuaryDay;\n  date.setUTCDate(date.getUTCDate() + diff);\n  return date;\n}\n\nfunction getTimezoneOffsetInMilliseconds(dirtyDate) {\n  const date = new Date(dirtyDate.getTime());\n  const baseTimezoneOffset = date.getTimezoneOffset();\n  date.setSeconds(0, 0);\n  const millisecondsPartOfTimezoneOffset = date.getTime() % MILLISECONDS_IN_MINUTE;\n  return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset;\n}","map":{"version":3,"sources":["../../../src/v2/legacyParse/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["'use strict'\nObject.defineProperty(exports, '__esModule', { value: true })\nconst date_fns_1 = require('date-fns')\nconst MILLISECONDS_IN_HOUR = 3600000\nconst MILLISECONDS_IN_MINUTE = 60000\nconst DEFAULT_ADDITIONAL_DIGITS = 2\nconst parseTokenDateTimeDelimeter = /[T ]/\nconst parseTokenPlainTime = /:/\n// year tokens\nconst parseTokenYY = /^(\\d{2})$/\nconst parseTokensYYY = [\n  /^([+-]\\d{2})$/,\n  /^([+-]\\d{3})$/,\n  /^([+-]\\d{4})$/ // 2 additional digits\n]\nconst parseTokenYYYY = /^(\\d{4})/\nconst parseTokensYYYYY = [\n  /^([+-]\\d{4})/,\n  /^([+-]\\d{5})/,\n  /^([+-]\\d{6})/ // 2 additional digits\n]\n// date tokens\nconst parseTokenMM = /^-(\\d{2})$/\nconst parseTokenDDD = /^-?(\\d{3})$/\nconst parseTokenMMDD = /^-?(\\d{2})-?(\\d{2})$/\nconst parseTokenWww = /^-?W(\\d{2})$/\nconst parseTokenWwwD = /^-?W(\\d{2})-?(\\d{1})$/\n// time tokens\nconst parseTokenHH = /^(\\d{2}([.,]\\d*)?)$/\nconst parseTokenHHMM = /^(\\d{2}):?(\\d{2}([.,]\\d*)?)$/\nconst parseTokenHHMMSS = /^(\\d{2}):?(\\d{2}):?(\\d{2}([.,]\\d*)?)$/\n// timezone tokens\nconst parseTokenTimezone = /([Z+-].*)$/\nconst parseTokenTimezoneZ = /^(Z)$/\nconst parseTokenTimezoneHH = /^([+-])(\\d{2})$/\nconst parseTokenTimezoneHHMM = /^([+-])(\\d{2}):?(\\d{2})$/\nfunction legacyParse(argument, options = {}) {\n  if (date_fns_1.isDate(argument)) {\n    // Prevent the date to lose the milliseconds when passed to new Date() in IE10\n    return new Date(argument.getTime())\n  } else if (typeof argument !== 'string') {\n    return new Date(argument)\n  }\n  const additionalDigits =\n    options.additionalDigits == null\n      ? DEFAULT_ADDITIONAL_DIGITS\n      : Number(options.additionalDigits)\n  const dateStrings = splitDateString(argument)\n  const parseYearResult = parseYear(dateStrings.date || '', additionalDigits)\n  const year = parseYearResult.year\n  const restDateString = parseYearResult.restDateString\n  const date = parseDate(restDateString || '', year)\n  if (date) {\n    const timestamp = date.getTime()\n    let time = 0\n    let offset\n    if (dateStrings.time) {\n      time = parseTime(dateStrings.time) || 0\n    }\n    if (dateStrings.timezone) {\n      offset = parseTimezone(dateStrings.timezone) * MILLISECONDS_IN_MINUTE\n    } else {\n      const fullTime = timestamp + time\n      const fullTimeDate = new Date(fullTime)\n      offset = getTimezoneOffsetInMilliseconds(fullTimeDate)\n      // Adjust time when it's coming from DST\n      const fullTimeDateNextDay = new Date(fullTime)\n      fullTimeDateNextDay.setDate(fullTimeDate.getDate() + 1)\n      const offsetDiff =\n        getTimezoneOffsetInMilliseconds(fullTimeDateNextDay) -\n        getTimezoneOffsetInMilliseconds(fullTimeDate)\n      if (offsetDiff > 0) {\n        offset += offsetDiff\n      }\n    }\n    return new Date(timestamp + time + offset)\n  } else {\n    return new Date(argument)\n  }\n}\nexports.default = legacyParse\nfunction splitDateString(dateString) {\n  const array = dateString.split(parseTokenDateTimeDelimeter)\n  let timeString, date, time, timezone\n  if (parseTokenPlainTime.test(array[0])) {\n    date = undefined\n    timeString = array[0]\n  } else {\n    date = array[0]\n    timeString = array[1]\n  }\n  if (timeString) {\n    const token = parseTokenTimezone.exec(timeString)\n    if (token) {\n      time = timeString.replace(token[1], '')\n      timezone = token[1]\n    } else {\n      time = timeString\n    }\n  }\n  return {\n    date,\n    time,\n    timezone\n  }\n}\nfunction parseYear(dateString, additionalDigits) {\n  const parseTokenYYY = parseTokensYYY[additionalDigits]\n  const parseTokenYYYYY = parseTokensYYYYY[additionalDigits]\n  let token\n  // YYYY or ±YYYYY\n  token = parseTokenYYYY.exec(dateString) || parseTokenYYYYY.exec(dateString)\n  if (token) {\n    const yearString = token[1]\n    return {\n      year: parseInt(yearString, 10),\n      restDateString: dateString.slice(yearString.length)\n    }\n  }\n  // YY or ±YYY\n  token = parseTokenYY.exec(dateString) || parseTokenYYY.exec(dateString)\n  if (token) {\n    const centuryString = token[1]\n    return {\n      year: parseInt(centuryString, 10) * 100,\n      restDateString: dateString.slice(centuryString.length)\n    }\n  }\n  // Invalid ISO-formatted year\n  return {\n    year: null\n  }\n}\nfunction parseDate(dateString, year) {\n  // Invalid ISO-formatted year\n  if (year === null) {\n    return null\n  }\n  let token\n  let date\n  let month\n  let week\n  // YYYY\n  if (dateString.length === 0) {\n    date = new Date(0)\n    date.setUTCFullYear(year)\n    return date\n  }\n  // YYYY-MM\n  token = parseTokenMM.exec(dateString)\n  if (token) {\n    date = new Date(0)\n    month = parseInt(token[1], 10) - 1\n    date.setUTCFullYear(year, month)\n    return date\n  }\n  // YYYY-DDD or YYYYDDD\n  token = parseTokenDDD.exec(dateString)\n  if (token) {\n    date = new Date(0)\n    const dayOfYear = parseInt(token[1], 10)\n    date.setUTCFullYear(year, 0, dayOfYear)\n    return date\n  }\n  // YYYY-MM-DD or YYYYMMDD\n  token = parseTokenMMDD.exec(dateString)\n  if (token) {\n    date = new Date(0)\n    month = parseInt(token[1], 10) - 1\n    const day = parseInt(token[2], 10)\n    date.setUTCFullYear(year, month, day)\n    return date\n  }\n  // YYYY-Www or YYYYWww\n  token = parseTokenWww.exec(dateString)\n  if (token) {\n    week = parseInt(token[1], 10) - 1\n    return dayOfISOYear(year, week)\n  }\n  // YYYY-Www-D or YYYYWwwD\n  token = parseTokenWwwD.exec(dateString)\n  if (token) {\n    week = parseInt(token[1], 10) - 1\n    const dayOfWeek = parseInt(token[2], 10) - 1\n    return dayOfISOYear(year, week, dayOfWeek)\n  }\n  // Invalid ISO-formatted date\n  return null\n}\nfunction parseTime(timeString) {\n  let token\n  let hours\n  let minutes\n  // hh\n  token = parseTokenHH.exec(timeString)\n  if (token) {\n    hours = parseFloat(token[1].replace(',', '.'))\n    return (hours % 24) * MILLISECONDS_IN_HOUR\n  }\n  // hh:mm or hhmm\n  token = parseTokenHHMM.exec(timeString)\n  if (token) {\n    hours = parseInt(token[1], 10)\n    minutes = parseFloat(token[2].replace(',', '.'))\n    return (\n      (hours % 24) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE\n    )\n  }\n  // hh:mm:ss or hhmmss\n  token = parseTokenHHMMSS.exec(timeString)\n  if (token) {\n    hours = parseInt(token[1], 10)\n    minutes = parseInt(token[2], 10)\n    const seconds = parseFloat(token[3].replace(',', '.'))\n    return (\n      (hours % 24) * MILLISECONDS_IN_HOUR +\n      minutes * MILLISECONDS_IN_MINUTE +\n      seconds * 1000\n    )\n  }\n  // Invalid ISO-formatted time\n  return null\n}\nfunction parseTimezone(timezoneString) {\n  let token\n  let absoluteOffset\n  // Z\n  token = parseTokenTimezoneZ.exec(timezoneString)\n  if (token) {\n    return 0\n  }\n  // ±hh\n  token = parseTokenTimezoneHH.exec(timezoneString)\n  if (token) {\n    absoluteOffset = parseInt(token[2], 10) * 60\n    return token[1] === '+' ? -absoluteOffset : absoluteOffset\n  }\n  // ±hh:mm or ±hhmm\n  token = parseTokenTimezoneHHMM.exec(timezoneString)\n  if (token) {\n    absoluteOffset = parseInt(token[2], 10) * 60 + parseInt(token[3], 10)\n    return token[1] === '+' ? -absoluteOffset : absoluteOffset\n  }\n  return 0\n}\nfunction dayOfISOYear(isoYear, week = 0, day = 0) {\n  const date = new Date(0)\n  date.setUTCFullYear(isoYear, 0, 4)\n  const fourthOfJanuaryDay = date.getUTCDay() || 7\n  const diff = week * 7 + day + 1 - fourthOfJanuaryDay\n  date.setUTCDate(date.getUTCDate() + diff)\n  return date\n}\nfunction getTimezoneOffsetInMilliseconds(dirtyDate) {\n  const date = new Date(dirtyDate.getTime())\n  const baseTimezoneOffset = date.getTimezoneOffset()\n  date.setSeconds(0, 0)\n  const millisecondsPartOfTimezoneOffset =\n    date.getTime() % MILLISECONDS_IN_MINUTE\n  return (\n    baseTimezoneOffset * MILLISECONDS_IN_MINUTE +\n    millisecondsPartOfTimezoneOffset\n  )\n}\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"script"}